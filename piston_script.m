% Notes:
%   Vectors of the form r_AB refer to the position vector of A with respect to the position of B
%   All vectors are defined in terms of the given Cartesian basis vectors, with an additional 
%       elementary vector k defined such that i cross j = k to span three-space and describe 
%       rotation.
%   All positions and velocities without a subscript to indicate where they're defined with 
%       respect to are defined with respect to point O 
%       - e.g. v_A is the vector of the velocity of point A with respect to O 
%       - O is fixed, and therefore it has no velocity or acceleration 
%   MATLAB is very weird, and amongst its oddities, it's not strongly typed. 
%       Furthermore, since symbolic variables act like their corresponding Greek letters and 
%       add subscrips based on the literal name of the variable when outputting display text, 
%       it may be hard to differentiate what's a vector and what's a scalar. I have come to the 
%       executive decision that it's better to keep track in my head and in my code, then to 
%       Hungarian-type every variable name, which would likely decrease legibility even more.
%       Most of the values you'd expect to be vectors are vectors anyways (typically 
%       with an i, j, and k components defined to span R^3 to allow for the use of the cross 
%       product).
%  Variables of the form disp_* are the corresponding `display' version of their corresponding 
%       variable without the disp_ prefix. They are intended to look nices for display, but 
%       are equivalent expressions (although there currently are not tools to evaluate this 
%       to numeric/double outputs). They are NOT sanity checked, and therefore must strictly 
%       match the algebra applied to their checked `parent' variable they're named after.

% This code takes a good while to run, primarily due to the displayable function handle being 
%   called so often in the attempt to simplify some expressions. It helps a bit, primarily for 
%   velocity terms, but the façade of simplicity drops very quickly, hence the `pure' constant 
%   parameter + time expressions being relegated to an appendix while their nicer-looking 
%   display versions are featured in the main body of the document. Note that this is still 
%   *nicer*, not nice, as they can still get rather ugly.


%% Settings
% Variable to store options passed to the script
%   It should be initialized as an array of strings
%   Valid entries include 
%       - "verbose" -- outputs verbose status messages 
%       - "write" -- writes various autogenerated files for use in document.tex
global options;

% MATLAB apparently doesn't like you defining variables in command line arguments using their 
%   own flags (as opposed to UNIX/POSIX piping outputs), so I'm going to define default 
%   behavior to enable file writing so it can be called from the command line to generate 
%   the final report without worrying about it
% It also apparently doesn't like you using the exists operator in a script called from the 
%   command line; it will not run the if statement below even when this line is ommited.
% One has to wonder how MATLAB scripts work at all if these are the hoops one must jump through 
%   to get the expected, "guaranteed" behavior MATLAB documentation defines.
options = ["write", "verbose"];

if (~exist("options"))
    fprintf("Could not find defined options variable, loading default script options.\n");
    options = [];
end



f = waitbar(0,"Beginning…");
% guarantee f will be closed if something goes wrong
dtor = onCleanup(@() close(f));


%% Parameter initialization 
% t is time, theta_0 is the angle theta when t = 0 seconds, g is gravity,
%   other parameters are given in problem description
% aside from t, all of these parameters are constant with respect to the system's time evolution
syms R H L m_c m_p omega t theta_0 g


% Pass redundant arguments by value now to make a cleaner, more easily modifiable 
%   function call
% make_presentable(expr_in, L,H, R, theta,theta_0, omega, t) 
% Of course, MATLAB is weird, and requires theta to exist in the workspace when this function 
%   is called, even though it should be passed by value here, but I digress.
% Basically a pseudo-simplification function based on a finite list of recognized 
%   simplifications the make_presentable function is told.
% This does not reduce the size of expressions to a reasonable size, but does help a little
displayable = @(expr) make_presentable(expr, L,H,R,theta,theta_0,omega,t);



%% Kinematics

waitbar(0.01,f,"Beginning kinematics…");

% define theta with respect to time (in radians)
theta = omega * t + theta_0;

% position of A with respect to O
%   define r in R^3 so we can take the cross product without adding on extra dimensions later
r_A = R*[cos(theta), sin(theta), 0];

% use the Pythagorean theorem to determine the vertical component of r_PA
r_PA = [H-R*cos(theta), sqrt(L^2 - (H-R*cos(theta))^2),0];
r_AP = -r_PA;

r_GA = 0.5 * r_PA;

r_P = r_A + r_PA;

r_G = r_A + r_GA;

% rearrange r_G = r_P + r_GP
r_GP = r_G - r_P;

v_A = diff(r_A, t);



% sanity check
assert(deep_equality(v_A, cross(omega*[0,0,1],r_A)), "Velocity of point A is not what's expected.");


waitbar(0.05,f,"Solving velocities…");

% linear algebra solves every problem if you know what you're doing 

% this expression is dealing with a lot of MATLAB's poor design choices
%   for example, use planar_truncate to reduce R^3 vectors into the plane (just keeps the first two
%       elements),
%   .' is actually the transpose operator in MATLAB, ' is NOT and picks up a conjugate term 
% use \ instead of ^(-1) to allow MATLAB to optimize this and produce warnings for non-unique 
%   equations
temp = [planar_truncate(cross([0,0,1],r_PA)).',[0;-1]] \ (planar_truncate(-cross(omega*[0,0,1],r_A)).');
% temp = [planar_truncate(cross([0,0,1],r_PA)).',[0;-1]]^(-1)* (planar_truncate(-cross(omega*[0,0,1],r_A)).');
% MATLAB isn't clever enough to let you immediately assign these values
omega_AP = temp(1);
v_P = temp(2);
clear temp;

waitbar(0.10,f,"Cleaning up velocities…");


% % at this point, this is the closest thing to simplification that can be done
v_P = displayable(v_P);
omega_AP = displayable(omega_AP);



assert(deep_equality(v_P*[0,1,0], diff(r_P, t)), "Velocity of point P is not what's expected.");
assert(deep_equality(v_A + omega_AP*cross([0,0,1],r_GA), diff(r_G, t)), "Velocity of point G is not what's expected.");


 waitbar(0.15,f,"Checking velocities…");

a_A = -omega^2*r_A;

assert(deep_equality(diff(v_A,t), a_A), "Acceleration of point A is not what's expected.");

waitbar(0.17,f,"Solving accelerations…");


% temp = [planar_truncate(cross([0,0,1],r_PA)).',[0;-1]]^(-1)*(planar_truncate(omega_AP^2*r_PA - a_A).');
temp = [planar_truncate(cross([0,0,1],r_PA)).',[0;-1]] \ (planar_truncate(omega_AP^2*r_PA - a_A).');
alpha_AP = temp(1);
a_P = temp(2);
clear temp;

waitbar(0.20,f,"Cleaning up acceleration…");

a_P = displayable(a_P);
alpha_AP = displayable(alpha_AP);

waitbar(0.25,f,"Checking accelerations…");

assert(deep_equality(a_P, diff(v_P, t)), "Acceleration of point P is not what's expected.");


a_G = a_A + alpha_AP*cross([0,0,1], r_GA) - omega_AP^2 * r_GA;
a_G = displayable(a_G);


assert(deep_equality(a_G, diff(r_G, t, 2)), "Acceleration of point G is not what's expected.");


waitbar(0.30,f,"Solving kinetics…");

%% Kinetics
I_G = 1/12 * m_c*L^2;
I_A = I_G + (L/2)^2*m_c;

% this is probably in a simpler form than a_G is right now, use this to get 
%   nicer expressions, probably
% also can't just directly type out diff every time because MATLAB doesn't like you indexing 
%   expressions, just variables for some reason
%temp_a_G = diff(r_G, t, 2);
% a_G is `nicer' than diff(r_G, t, 2) is right now, so use that instead, but keep as a 
%   variable that can be easily change should better simplification become available
temp_a_G = a_G;

% get P_y from FBD about the piston
%   NOTE -- P_y points in the -i direction on this FBD, despite pointing in the +i dir on 
%       the FBD of the rod
P_y = -m_p*(a_P + g);
% get A_y from FBD of the rod
A_y = m_c * temp_a_G(2) - P_y;

% from sum of moments on the crank in the k dir about point A 
P_x = (-I_A * alpha_AP - m_c * g * (r_PA(1))/2 + P_y * r_PA(1))/(r_PA(2));
% from sum of forces of the crank
A_x = m_c * temp_a_G(1) - P_x;

 waitbar(0.35,f,"Cleaning up kinetics (component-wise)…");

P_x = displayable(P_x);
A_x = displayable(A_x);
P_y = displayable(P_y);
A_y = displayable(A_y);


waitbar(0.50,f,"Cleaning up kinetics (magnitude)…");

clear temp_a_G;


% Magnitude 
A = sqrt(A_x^2 + A_y^2);
P = sqrt(P_x^2 + P_y^2);

% A = displayable(A);
% P = displayable(P);


 waitbar(0.70,f,"Defining useful quantities…");

%% Function handles

% Save handles to convenient functions for use in the command window
loadParams = @load_params;
randParams = @random_params;
combineParams = @combine_params;
deepEquality = @deep_equality;
bruteForce = @check_equality_brute_force;

%% Define cases


case1.L_by_R = 3/2;
case1.H_by_R = 0;

case2.L_by_R = 8/3;
% This used to be 5/3, which resulted in some *interesting* graphs, as well as some divide
%   by zero errors when the offset are too small for some reason
%       (I'm not manually analyzing those function to find out why)
% Change it back if you want to see some steep force jumps and piecewise-esque behavior
case2.H_by_R = 1/3;

case3.L_by_R = 4;
case3.H_by_R = 5/3;

cases = [case1, case2, case3];


% Inside the array are the given angular velocities in rpm, convert to rad/s as the 
%   God Lord intended
omega_values = [1000, 2200, 5000] * 2 * pi / 60;
omega_strs = ["1,000 rpm", "2,200 rpm", "5,000 rpm"];



%% Display 'simplification' variables

% Since redefining theta breaks the pass-by-value argument of theta somehow, destroy the displayable 
%   function handle to make it harder to accidentally call after this point
clear displayable 


% NOTE -- any changes to the above code must be propogated here
% Also, statements here are not sanity checked, hence the need for this to be a mirror of the 
%   above code.
% Also, the function (handle) displayable no longer works here, since theta is re-initialized,
%   and syms variables behave weirdly when passed by value after their original value is 
%   destroyed.

%% Kinematics

 waitbar(0.71,f,"Solving display kinematics…");


% % Let h = H-Rcos(theta), l = sqrt(L^2 - h^2)
syms h l theta


% position of A with respect to O
%   define r in R^3 so we can take the cross product without adding on extra dimensions later
disp_r_A = R*[cos(theta), sin(theta), 0];

% use the Pythagorean theorem to determine the vertical component of r_PA
% r_PA = [H-R*cos(theta), sqrt(L^2 - (H-R*cos(theta))^2),0];
disp_r_PA = [h,l,0];
disp_r_AP = -disp_r_PA;

disp_r_GA = 0.5 * disp_r_PA;
disp_r_P = disp_r_A + disp_r_PA;
disp_r_G = disp_r_A + disp_r_GA;

% rearrange r_G = r_P + r_GP
disp_r_GP = disp_r_G - disp_r_P;


% linear algebra solves every problem if you know what you're doing 

% this expression is dealing with a lot of MATLAB's poor design choices
%   for example, use planar_truncate to reduce R^3 vectors into the plane (just keeps the first two
%       elements),
%   .' is actually the transpose operator in MATLAB, ' is NOT and picks up a conjugate term 
% use \ instead of ^(-1) to allow MATLAB to optimize this and produce warnings for non-unique 
%   equations
temp = [planar_truncate(cross([0,0,1],disp_r_PA)).',[0;-1]] \ (planar_truncate(-cross(omega*[0,0,1],disp_r_A)).');
% temp = [planar_truncate(cross([0,0,1],r_PA)).',[0;-1]]^(-1)* (planar_truncate(-cross(omega*[0,0,1],r_A)).');
% MATLAB isn't clever enough to let you immediately assign these values
disp_omega_AP = temp(1);
disp_v_P = temp(2);
clear temp;

% % at this point, this is the closest thing to simplification that can be done
% disp_v_P = displayable(disp_v_P);
% disp_omega_AP = displayable(disp_omega_AP);

disp_a_A = -omega^2*disp_r_A;


% temp = [planar_truncate(cross([0,0,1],r_PA)).',[0;-1]]^(-1)*(planar_truncate(omega_AP^2*r_PA - a_A).');
temp = [planar_truncate(cross([0,0,1],disp_r_PA)).',[0;-1]] \ (planar_truncate(disp_omega_AP^2*disp_r_PA - disp_a_A).');
disp_alpha_AP = temp(1);
disp_a_P = temp(2);
clear temp;

% disp_a_P = displayable(disp_a_P);
% disp_alpha_AP = displayable(disp_alpha_AP);

disp_a_G = disp_a_A + disp_alpha_AP*cross([0,0,1], disp_r_GA) - disp_omega_AP^2 * disp_r_GA;
% disp_a_G = displayable(disp_a_G);



%% Kinetics


waitbar(0.80,f,"Solving display kinetics…");

% these are nice enough to leave as-is
I_G = 1/12 * m_c*L^2;
I_A = I_G + (L/2)^2*m_c;

% this is probably in a simpler form than a_G is right now, use this to get 
%   nicer expressions, probably
% also can't just directly type out diff every time because MATLAB doesn't like you indexing 
%   expressions, just variables for some reason
%temp_a_G = diff(r_G, t, 2);
% a_G is `nicer' than diff(r_G, t, 2) is right now, so use that instead, but keep as a 
%   variable that can be easily change should better simplification become available
temp_a_G = disp_a_G;

% get P_y from FBD about the piston
%   NOTE -- P_y points in the -i direction on this FBD, despite pointing in the +i dir on 
%       the FBD of the rod
disp_P_y = -m_p*(disp_a_P + g);
% get A_y from FBD of the rod
disp_A_y = m_c * temp_a_G(2) - disp_P_y;

% from sum of moments on the crank in the k dir about point A 
disp_P_x = (-I_A * disp_alpha_AP - m_c * g * (disp_r_PA(1))/2 + disp_P_y * disp_r_PA(1))/(disp_r_PA(2));
% from sum of forces of the crank
disp_A_x = m_c * temp_a_G(1) - disp_P_x;

% disp_P_x = displayable(disp_P_x);
% disp_A_x = displayable(disp_A_x);
% disp_P_y = displayable(disp_P_y);
% disp_A_y = displayable(disp_A_y);

clear temp_a_G;



%% Autogeneration of *.tex files
if (sum(options.contains("write")))


    % MATLAB is weird and introduces a quasi-RAII (Resource Aquisition Is Initialization) 
    %   destructor scheme, and then fails to innately guarantee stuff will go out of scope 
    % Therefore, my choices are either wrap everything in one function and not define the 
    %   symbolic expressions in the command window workspace, which I don't want, to 
    %   declare them all as global variables, which is bad practice and I also don't want,
    %   to pass them all into a function which would be a hassle, or to add a try-catch 
    %   statement here as a failsafe 
    try 
        waitbar(0.85,f,"Writing equations…");
        fobj_fn_def = gen_file("fn_def");

        % fid, section name, section label (replace with "" for none)
        append_section(fobj_fn_def.fid, "Function Definitions", "appendix:definitions");
        % fid, variable name, symbolic Right Hand side, label (can be "" for none),
        %   and a logical/boolean value for if the equation should be scaled to fit within the 
        %   given column

        append_text(fobj_fn_def.fid, "The following equations are the resultant equations"...
            + " from this document expressed purely in terms of the system's constant parameters"...
            + " and time. The following expressions are mostly simplified, but may still be "...
            + "unweildy both due to their inherent complexity and , hence the more easily understood expressions used throughout the body"...
            + " of the document. Nevertheless, it is useful to see that these expressions can "...
            + "be reduced to given values and time, and serve as a reference for re-constructing"...
            + " graphs if need be.");

        append_equation(fobj_fn_def.fid, "v_{\,\textrm{P}}", v_P, "fn_defv:P", true);
        append_equation(fobj_fn_def.fid, "\omega_{\textrm{AP}}", omega_AP, "fn_def:omega:AP", false);
        append_equation(fobj_fn_def.fid, "a_{\,\textrm{P}}", a_P, "fn_def:a:P", true);
        append_equation(fobj_fn_def.fid, "\alpha_{\textrm{AP}}", alpha_AP, "fn_def:alpha:AP", true);
        append_equation(fobj_fn_def.fid, "A_{\textrm{x}}", A_x, "fn_def:A:x", true);
        append_equation(fobj_fn_def.fid, "A_{\textrm{y}}", A_y, "fn_def:A:y", true);
        append_equation(fobj_fn_def.fid, "P_{\textrm{y}}", P_y, "fn_def:P:y", true);
        append_equation(fobj_fn_def.fid, "P_{\textrm{x}}", P_x, "fn_def:P:x", true);
        append_equation(fobj_fn_def.fid, "A", A, "fn_def:A", true);
        append_equation(fobj_fn_def.fid, "P", P, "fn_def:P", true);


        fobj_vel = gen_file("vel");
        append_equation(fobj_vel.fid, "v_{\,\textrm{P}}", disp_v_P, "v:P", false);
        append_equation(fobj_vel.fid, "\omega_{\textrm{AP}}", disp_omega_AP, "omega:AP", false);

        fobj_acc = gen_file("acc");
        append_equation(fobj_acc.fid, "a_{\,\textrm{P}}", disp_a_P, "a:P", true);
        append_equation(fobj_acc.fid, "\alpha_{\textrm{AP}}", disp_alpha_AP, "alpha:AP", false);

        fobj_Py = gen_file("P_y");
        append_equation(fobj_Py.fid, "P_y", disp_P_y, "P:y", true);

        waitbar(0.87,f,"Writing graphs…");

        % Graphs!
        fobj_graphs = gen_file("graphs");
  
        append_section(fobj_graphs.fid, "Graphs", "appendix:graphs");
        append_text(fobj_graphs.fid, "Note that the following graphs are generated for an " + ...
            "initial angle $\theta_0 = 0$ radians.");

        default_legend = ["Case 1", "Case 2", "Case 3"];
        default_colors = ["red","blue","black"];

        append_subsection(fobj_graphs.fid, "Piston Velocity", "appendix:piston_vel");
        for i = 1:length(omega_values)
            append_graph(fobj_graphs.fid, ...
                bulk_gen_plot(v_P, cases, omega_values(i), 10^-3), ...
                default_colors, default_legend, ...
                "Piston velocity over time for " + omega_strs(i), "graph:v_P_omega" + i, ...
                "ylabel={Velocity ($\sfrac{\textrm{m}}{\textrm{s}}$)},xlabel={time (ms)},legend pos = south east");
        end

        append_subsection(fobj_graphs.fid, "Piston Acceleration", "appendix:piston_accel");
        for i = 1:length(omega_values)
            append_graph(fobj_graphs.fid, ...
                bulk_gen_plot(a_P, cases, omega_values(i), 10^-3), ...
                default_colors, default_legend, ...
                "Piston acceleration over time for " + omega_strs(i), "graph:a_P_omega" + i, ...
                "ylabel={Acceleration ($\sfrac{\textrm{m}}{\textrm{s}^2}$)},xlabel={time (ms)},legend pos = south east,scaled ticks=false");
            % scaled ticks = false prevents the * 10^n appearing at the top of the graph, but does 
            %   seem to limit the number of tick marks on the y-axis for the piston accleration vs time 
            %   graph at 5,000 rpm
        end

        append_subsection(fobj_graphs.fid, "Connecting Rod Acceleration", "appendix:accel");
        for i = 1:length(omega_values)
            append_graph(fobj_graphs.fid, ...
                bulk_gen_plot(a_G(1), cases, omega_values(i), 10^-3), ...
                default_colors, default_legend, ...
                "Connecting rod center of gravity vertical acceleration over time for " + omega_strs(i), "graph:a_Gx_omega" + i, ...
                "ylabel={Acceleration ($\sfrac{\textrm{m}}{\textrm{s}^2}$)},xlabel={time (ms)},scaled ticks=false");

            append_graph(fobj_graphs.fid, ...
                bulk_gen_plot(a_G(2), cases, omega_values(i), 10^-3), ...
                default_colors, default_legend, ...
                "Connecting rod center of gravity horizontal acceleration over time for " + omega_strs(i), "graph:a_Gy_omega" + i, ...
                "ylabel={Acceleration ($\sfrac{\textrm{m}}{\textrm{s}^2}$)},xlabel={time (ms)},legend pos = south east,scaled ticks=false");
        end

        append_subsection(fobj_graphs.fid, "Pin Forces", "appendix:accel");
        for i = 1:length(omega_values)
            % (fid, plots, plot_opts, legends, fig_caption, fig_label, graph_options)
            append_graph(fobj_graphs.fid, ...
                bulk_gen_plot(A, cases, omega_values(i), 10^-3), ...
                default_colors, default_legend, ...
                "Shear force at A over time for " + omega_strs(i), "graph:A_omega" + i, ...
                "ylabel={Force (N)},xlabel={time (ms)},scaled ticks=false");

            append_graph(fobj_graphs.fid, ...
                bulk_gen_plot(P, cases, omega_values(i), 10^-3), ...
                default_colors, default_legend, ...
                "Shear force at P over time for " + omega_strs(i), "graph:P_omega" + i, ...
                "ylabel={Force (N)},xlabel={time (ms)},scaled ticks=false");
        end

        clear fobj*;
    catch ME
        waitbar(0,f,"Failed.");
        clear dtor
        clear fobj*;
        % Definitely didn't forget this earlier and wonder why some of the code in the 
        %   try statement wasn't executing when I didn't get any warnings/errors...
        rethrow(ME);
    end
end

waitbar(1,f,"Finished.");
clear dtor


% utility function to convert a vector in R^3 to one in R^2. MATLAB is stupid and doesn't allow 
%   something of the form (expression that results in a vector) to be indexed directly
% MATLAB is an interpreted language, it should have all the weird, fun stuff other interpreted 
%   languages have. At least have swizzles...
% This function is stupid, and will literally just cut off every element after the first and second
% If you give it a vector that doesn't have two or more elements, that's UB 
%       (it'll probably throw an error but I'm not going to guarantee that)
function vec2 = planar_truncate(vec3) 
    vec2 = vec3(1:2);
end

% Checks if two symbolic expressions are equivalent 
% Valid for expr1 and expr2 of type 'symbolic' that can be cast to a 'double' 
%   through the use of load_params (macro-esque substitution of the symbolic variables
%   initialized above)
% Anything else is Undefined Behavior, but might work
% May warn users of a sign error they have, but this behavior is not guaranteed for all inputs.
function equal = deep_equality(expr1, expr2) 
    equal = true;
    if (length(expr1) ~= length(expr2)) 
        equal = false;
        return;
    end
    for i = 1:length(expr1) 
        s_expr1 = simplify(expr1(i));
        s_expr2 = simplify(expr2(i));


        % do a heuristical check to see if the expressions simplify into the same form
        if (isequal(s_expr1, s_expr2))
            break;
        end

        s_expr1 = simplify(combine(simplifyFraction(expr1(i))), 'Steps',50);
        s_expr2 = simplify(combine(simplifyFraction(expr2(i))), 'Steps',50);

        try 
            % make isAlways throw an error when it can neither prove nor disprove equality
            if (~isAlways(s_expr1 == s_expr2, Unknown="error"))
                equal = false;
                return;
            end
        catch ME 
            % if analytic methods fail, simply brute force check 50 points for approximate equality
            % TODO -- add justification for tolerance and discuss acceptable failure probabilities
            % What are the odds this *and* our calculationrs are wrong?
            % TODO -- replace tolerance with 0.5 from histogram?
            equal = check_equality_brute_force(expr1(i), expr2(i), 10, 0.001); 
            if (~equal) 
                return;
            end
        end
    end
end

% Same contract applies to expr1 and expr2 here as they do in deep_equality
% When all else fails, substitute out the variables inside the expressions with a numeric 
%   dummy variable num times, cast the resultant expression to a double floating point 
%   number, and compare these expressions to each other to see if they're within the tolerance 
%   given.
% Also warns of potential sign errors in the chance it catches them, but this is not guaranteed.
function equal = check_equality_brute_force(expr1, expr2, num, tolerance)
    equal = true;
    for i = 1:num 
        p = random_params();
        value1 = load_params(expr1, p);
        value2 = load_params(expr2, p);

        % complex values are only a problem if they're not equal, luckily
        % assert(isreal(value1) && isreal(value2), "Expression evaluation yields complex outputs.");

        % floating point numbers can't be compared against each other accurately, need a tolerance 
        %   value
        if (abs(value1 - value2) > tolerance) 
            equal = false;

            if (abs(value1) + abs(value2) <= tolerance) 
                fprintf("Passed expressions are (almost) exactly opposite. Did you make a sign error?\n");
            end

            return;
        end
    end
end

% generates a random, valid parameter list for the sake of testing equality
function params = random_params() 
    params.R = rand() * 10 + 0.1;
    params.H = rand() * 10 + params.R + 0.01;

    params.g = 9.81;

    params.m_c = rand() * 10 + 0.1;
    params.m_p = rand() * 10 + 0.1;

    params.theta_0 = 0;
    params.omega = rand() * 1000 + 100;
    params.t = rand()*10;
    params.L = rand() * 10 + (params.H - params.R) + 0.01;
end

% loads a struct called param defining every variable to get a numerical value out 
%   all (useful) fields of param must be initialized to an object that can be 
%       cast to a double
%   params.t is allowed to be a vector (array), everything else must be a scalar
%       If params.t is a vector, out is also a vector with corresponding indices to params.t
%   g is allowed to be left uninitialized if you want it to default to 9.81 m/s^2
% If parameters are not physically possible, or otherwise do not lead to well-defined behavior 
%   when inputted into expr, the resultant value(s) are Undefined Behavior
function out = load_params(expr, params) 
    syms R H L m_c m_p omega t theta_0 g theta l h
    assert(isfield(params, 'H'), "Parameter field property 'H' is not defined.");
    assert(isfield(params, 'R'), "Parameter field property 'R' is not defined.");
    assert(isfield(params, 'L'), "Parameter field property 'L' is not defined.");

    assert(isfield(params, 'm_c'), "Parameter field property 'm_c' is not defined.");
    assert(isfield(params, 'm_p'), "Parameter field property 'm_p' is not defined.");

    assert(isfield(params, 'omega'), "Parameter field property 'omega' is not defined.");

    if(~isfield(params, 'theta_0'))
        fprintf("Defaulting to an initial angle of 0 radians for t = 0 seconds.\n");
        params.theta_0 = 0;
    end

    assert(isfield(params, 't'), "Parameter field property 't' is not defined.");

    if (~isfield(params, 'g'))
        fprintf("Defaulting gravity to 9.81 m/s^2. If you are not using SI base units, " ...
            + "please define this properly for your coherent unit system.\n");
        params.g = 9.81;
    end

    expr = subs(expr, "H", params.H);
    expr = subs(expr, "R", params.R);
    expr = subs(expr, "L", params.L);
    expr = subs(expr, "m_c", params.m_c);
    expr = subs(expr, "m_p", params.m_p);
    expr = subs(expr, "omega", params.omega);
    expr = subs(expr, "theta_0", params.theta_0);
    expr = subs(expr, "t", params.t);
    expr = subs(expr, "g", params.g);

    if (has(expr, theta))
        warning("The following expression contains theta expicitly, rather than constructing "...
            + "theta from constant parameters and time:    " + string(expr) +"       You probably "...
            + "called load_params on a display-only variable")
        expr = subs(expr, "theta", params.theta_0 + params.omega*params.t);
    end
    if (has(expr, l))
        warning("The following expression contains l expicitly, rather than constructing "...
            + "l from constant parameters and time:    " + string(expr) +"       You probably "...
            + "called load_params on a display-only variable")
        expr = subs(expr, "l", params.H - params.R * cos(params.theta_0 + params.omega*params.t));
    end
    if (has(expr, h))
        warning("The following expression contains h expicitly, rather than constructing "...
            + "h from constant parameters and time:    " + string(expr) +"       You probably "...
            + "called load_params on a display-only variable")
        expr = subs(expr, "h", ...
            sqrt(params.L^2 - (params.H - params.R * cos(params.theta_0 + params.omega*params.t))^2));
    end

    % cast result from symbolic expression to double
    % at this point, every variable in expr ought to have been substituded out with a numeric form 
    
    out = double(expr);
end

% Automatically generates/overwrites the file autogen_ + name + .tex,
%   and returns an object containing an fid to that file and a destructor object 
%   that will automatically fclose that file when it goes out of scope
%   Valid fid's are guaranteed to be fclose'd after the safe_out object goes out of scope/is cleared,
%       but an fid is not guaranteed to be valid (might run into permission issues)
function safe_out = gen_file(name)
    global options;
    assert(sum(options.contains("write")), "Writing to files has been disabled by default, do not "...
        + "call this method without re-enabling it.");

    [fid, err] = fopen("autogen_" + name + ".tex", 'w');
    
    assert(fid >= 0, "Failed to obtain valid file ID for autogen_" + name + ".tex due to "...
        + err + ".");

    % pass fid by value
    % dtor's should be guaranteed to be executed in order in a vector
    safe_out.dtors = [
        onCleanup(@() fprintf(fid,"\n\\end{document}")),
        onCleanup(@() fclose(fid))
    ];

    % pass name by value
    if (sum(options.contains("verbose")))
        safe_out.dtors(3) = onCleanup(@() fprintf("File autogen_" + name + ".tex successfully closed.\n"));
    end

    safe_out.fid = fid;

    % MATLAB is an idiotic language and doesn't have string literals for some reason
    % char array because strings don't like delimiters as much
    % char(10) = sprintf("\n")
    preamble = join(char(10), {
        '%%    █████╗ ██╗   ██╗████████╗ ██████╗  ██████╗ ███████╗███╗   ██╗███████╗██████╗  █████╗ ████████╗███████╗██████╗ ',
        '%%   ██╔══██╗██║   ██║╚══██╔══╝██╔═══██╗██╔════╝ ██╔════╝████╗  ██║██╔════╝██╔══██╗██╔══██╗╚══██╔══╝██╔════╝██╔══██╗',
        '%%   ███████║██║   ██║   ██║   ██║   ██║██║  ███╗█████╗  ██╔██╗ ██║█████╗  ██████╔╝███████║   ██║   █████╗  ██║  ██║',
        '%%   ██╔══██║██║   ██║   ██║   ██║   ██║██║   ██║██╔══╝  ██║╚██╗██║██╔══╝  ██╔══██╗██╔══██║   ██║   ██╔══╝  ██║  ██║',
        '%%   ██║  ██║╚██████╔╝   ██║   ╚██████╔╝╚██████╔╝███████╗██║ ╚████║███████╗██║  ██║██║  ██║   ██║   ███████╗██████╔╝',
        '%%   ╚═╝  ╚═╝ ╚═════╝    ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝ ',
        '',
        '',
        '%% This document is auto-generated as a result of running the MATLAB script piston_script.m with the option write enabled.',
        '%% It is NOT guaranteed to be (easily) human-readable.',
        "%% Generated on " + date + ".",
        '',
        '',
        '',
        '',
        '\documentclass[]{subfiles}',
        '\begin{document}'
    });

    fprintf(fid, "%s", preamble);
end

% appends a valid LaTeX equation to a file
function append_equation(fid, name, expr, label, scale)
    if (~isempty(label))
        label = "\label{" + label + "}";
    end

    % Another MATLAB oddity, str is defined everywhere in this function after the if statement 
    % Pretty much every other language would have it go out of scope
    if (scale) 
        % char(10) = sprintf("\n")
        str = join(char(10), {
            '',
            '\begin{equation}' + label,
            '\resizebox{1.0\hsize}{!}{$',
            name + "=" + latex(expr), 
            '$}',
            '\end{equation}',
            ''
        });
    else 
        % char(10) = sprintf("\n")
        str = join(char(10), {
            '',
            '\begin{equation}' + label,
            name + "=" + latex(expr), 
            '\end{equation}',
            ''
        });
    end


    fprintf(fid, "%s", str);
end

% appends a section 
function append_section(fid, name, label)
    str = "\section{" + name + "}";    

    if (~isempty(label)) 
        str = str + "\label{" + label + "}";
    end

    fprintf(fid, "%s", str);
end

% appends a subsection 
function append_subsection(fid, name, label)
    str = "\subsection{" + name + "}";    

    if (~isempty(label)) 
        str = str + "\label{" + label + "}";
    end

    fprintf(fid, "%s", str);
end

function append_text(fid, str) 
    fprintf(fid, "%s", str);
end

function append_graph(fid, plots, plot_opts, legends, fig_caption, fig_label, graph_options)

    % writing to a string like this is probably slow, but it is what it is 
    str = "\begin{figure}[H]\begin{tikzpicture}\begin{axis}[" + graph_options + "]";

    for i = 1:length(plots) 
        str = str + "\addplot[" + plot_opts(i) + "] coordinates {" + plots(i) + "};";
    end

    if (length(legends) > 0) 
        str = str + "\legend{";
        for i = 1:length(legends)
            str = str + legends(i) + ",";
        end
        str = str + "};";
    end

    str = str + "\end{axis}\end{tikzpicture}";

    if (strlength(fig_caption) > 0) 
        str = str + "\caption{" + fig_caption+ "}";
        if (strlength(fig_label) > 0) 
            str = str + "\label{" + fig_label + "}";
        end
    end

    str = str + "\end{figure}";

    fprintf(fid, "%s", str);
end

function str = gen_plot_coords(x, y) 
    str = "";
    for i = 1:length(x)
        str = str + "(" + x(i) + "," + y(i) + ") ";
    end
end

% time conversion is a scale factor on time in case you wanted to plot the x-axis in milliseconds
function strs = bulk_gen_plot(expr, cases, omega, time_conversion) 
    strs = string(ones(1,length(cases)));
    for i = 1:length(cases) 
        p = combine_params(cases(i), omega);
        strs(i) = gen_plot_coords(p.t / time_conversion, load_params(expr, p));
    end
end

% Takes a case (object so as not to collide with the switch-case keyword) and an angular velocity,
%   returns a valid params 'struct' with a timespan of one rotation of 2*pi for theta
function p = combine_params(case_obj, omega) 
    p.R = 0.075;
    p.m_c = 0.3;
    p.m_p = 0.4;
    % Because we really don't care what the initial angle is
    p.theta_0 = 0;
    p.g = 9.81;

    p.L = p.R * case_obj.L_by_R;
    p.H = p.R * case_obj.H_by_R;

    p.omega = omega;

    % Generate this many points
    % TURN THIS DOWN TO SPEED UP COMPILATION FOR TESTING OTHER THINGS, THEN TURN BACK UP FOR 
    %   FINAL COMPILATION
    % NUM_PTS = 200;
    % NUM_PTS = 200;
    % 100 actually does a very good job
    % NUM_PTS = 100;
     NUM_PTS = 50;

    max_time = 2*pi / omega;

    % this is probably off by one, but if we take the limit case as NUM_PTS -> \infty, that goes 
    %   away, and we want to have a large number of NUM_PTS, therefore, it's fine
    p.t = 0:(max_time/NUM_PTS):max_time;
end

% Takes in a Symbolic expression, returns said symbolic expression with simplificats made 
%   for clarity when displayed.
% Guaranteed to return an equivalent symbolic expression that's probably in a more presentable,
%   human-readable form.
%   - The guarantee is only on an equivalent expression output (assuming real inputs for variables,
%       complex output of the expression via load_params IS well defined because loading random 
%       parameters to test for equality via brute force can lead to complex outputs. However, 
%       equivalence is NOT guaranteed for complex inputs or for negative L, so sqrt(L^2) can be 
%       displayed as L
% Replaces -H^2 + 2HR cos(theta) - R^2 * cos(theta) with -(H - Rcos(theta))^2
%   for display purposes
% H, R, etc. are symbolic variables, and are intended to be the same variables as defined in the 
%   `main' workspace
function expr_out = make_presentable(expr_in, L,H, R,theta,theta_0, omega, t) 

    % substitute what used to be this:
    expr_sub_out = [-H^2+L^2 + 2*H*R*cos(theta_0 + omega*t) - R^2 *cos(theta_0 + omega*t)^2,...
        H^2 - 2*H*R*cos(theta_0 + omega*t) - L^2 + R^2 * cos(theta_0 + omega*t)^2,...
        H^2*cos(theta_0 + omega*t) - 2*H*R*cos(theta_0 + omega*t)^2 - L^2*cos(theta_0 + omega*t) + R^2 * cos(theta_0 + omega*t)^3];
    % with this:
    % INDICES MUST MATCH
    % NOTE -- MATLAB is very stupid, and will take your adding spaces to this expression below 
    %   as having multiple entries in it
    % Somehow, the same does not apply to expr_sub_out above?
    
    theta = theta_0 + omega*t;

    expr_sub_in = [L^2-(H-R*cos(theta))^2, -L^2+(H-R*cos(theta))^2,cos(theta)*(-L^2+(H-R*cos(theta))^2)];

    assert(length(expr_sub_in) == length(expr_sub_out), "MATLAB bullshit detected: "...
        + "some implicit array entries are being added to expr_sub_in again.");

    expr_out = expr_in;

    for i = 1:length(expr_sub_out) 
        % expr_sub_out(i) 
        % expr_sub_in(i)

        assert(deep_equality(expr_sub_out(i), expr_sub_in(i)), "Substitutional expression " ...
            + i + " are not equivalent.");

        expr_out = subs(expr_out, expr_sub_out(i), expr_sub_in(i));
    end

    % MATLAB is perfectly fine accepting a string for the assumptions, but only if it's a single one 
    % You need to use character vectors and a cell array to add multiple conditions in one line...
    % One has to wonder what goes on in the minds of MATLAB's developers
    assume(L, {'real', 'positive'});
    expr_out = simplify(expr_out, 'Steps', 10);
    expr_out = combine(expr_out);
    % expr_out = simplifyFraction(expr_out);
    % expr_out = combine(expr_out);

    % expr_out = simplify(expr_out, 'Steps', 10);

    assert(deep_equality(expr_in, expr_out), "Simplification failed to yield overall equivalent expression.");
end


% MATLAB lacks string literals, use this solution instead 
% from https://stackoverflow.com/questions/14233896/multiline-string-literal-in-matlab
function out = join(glue, strs)
    strs = strs(:)';
    strs(2,:) = {glue};
    strs = strs(:)';
    strs(end) = [];
    out = cat(2, strs{:});
end
